const fs = require('fs');
const xmlParser = require('xml2json');
const { execSync } = require('child_process');

const englishCopiesFileLocation = 'src/locale/messages.xmb';
const spanishCopiesFileLocation = 'src/locale/es.xtb';
const mainCopiesFileLocation = englishCopiesFileLocation;
const keyPrefix = 'web_';
const translationsFilesLocations = [
  englishCopiesFileLocation,
  spanishCopiesFileLocation
];
const pathsToSkip = [
  'node_modules'
];


class I18nNormalizer {
  private escapeLesserThan = '$LESSER_THAN';
  private escapeGreaterThan = '$GREATER_THAN';
  private translations = [];

  private cumulativeIndex = 0;
  private recursiveIteration = 1;

  public main() {
    // Load in memory original translations
    this.loadTranslationsDatabase();

    // Ensure all i18n copies have manual keys and update copies
    this.addMissingKeys(false); // assuming `yarn i18n` does not generate new messages

    // Format all keys with snake_case, add prefix and simplify key name
    this.normalizeKeys();
  }

  private loadTranslationsDatabase() {
    const originalNodeMessages = this.getNodeMessages(false, englishCopiesFileLocation);
    const spanishNodeMessages = this.getNodeMessages(false, spanishCopiesFileLocation);

    originalNodeMessages.forEach(originalNodeMessage => {
      spanishNodeMessages.forEach(spanishNodeMessage => {
        const isSameId = originalNodeMessage.id === spanishNodeMessage.id;

        if (isSameId) {
          const numericKey = this.isKeyNumeric(originalNodeMessage.id) ? originalNodeMessage.id : null;
          const translationRelation = {
            numericKey,
            mainKey: originalNodeMessage.id,
            es: spanishNodeMessage.text,
            en: originalNodeMessage.text
          };
          this.translations.push(translationRelation);
        }
      });
    });
  }

  private cleanupRawXMB(rawStringFile) {
    const translationTagSeparator = `msg`;
    const regexpMatchTranslationSeparatorsAperture = new RegExp(`</source>`, 'g');
    const regexpMatchTranslationSeparatorsClosure = new RegExp(`</${translationTagSeparator}>`, 'g');
    const apertureReplacement = '</source><text>';
    const closureReplacement = `</text></${translationTagSeparator}>`;
    const regexpCleanupInterpolations = new RegExp('/<ph.*\/>/', 'g');
    const interpolationsReplacement = '__INTERPOLATION__';

    return rawStringFile
      .replace(regexpMatchTranslationSeparatorsAperture, apertureReplacement)
      .replace(regexpMatchTranslationSeparatorsClosure, closureReplacement)
      .replace(regexpCleanupInterpolations, interpolationsReplacement);
  }

  private cleanupRawXTB(rawStringFile) {
    const allLines = rawStringFile.split('\n');
    allLines.forEach((line, i) => {
      line = line.replace(/<ph/g, `${this.escapeLesserThan}ph`);
      line = line.replace(/<ex>/g, `${this.escapeLesserThan}ex${this.escapeGreaterThan}`);
      line = line.replace(/<\/ex>/g, `${this.escapeLesserThan}/ex${this.escapeGreaterThan}`);
      line = line.replace(/<\/ph>/g, `${this.escapeLesserThan}/ph${this.escapeGreaterThan}`);
      allLines[i] = line;
    });

    return allLines.join('\n');
  }

  private getTranslationNodesFromFile(copiesFileLocation) {
    const rawCopiesFile = fs.readFileSync(copiesFileLocation, 'utf8');

    const isXMB = copiesFileLocation.endsWith('.xmb');
    const isXTB = copiesFileLocation.endsWith('.xtb');

    if (isXMB) {
      const cleanedFileString = this.cleanupRawXMB(rawCopiesFile);
      const rawCopiesJSON = xmlParser.toJson(cleanedFileString);
      const copiesObject = JSON.parse(rawCopiesJSON);
      return copiesObject.messagebundle.msg;
    }

    if (isXTB) {
      const cleanedFileString = this.cleanupRawXTB(rawCopiesFile);
      const rawCopiesJSON = xmlParser.toJson(cleanedFileString, { alternateTextNode: 'text' } );
      const copiesObject = JSON.parse(rawCopiesJSON);
      return copiesObject.translationbundle.translation;
    }

    return [];
  }

  private isKeyNumeric(id) {
    return !isNaN(id) && !isNaN(parseFloat(id));
  }

  private getNodeMessages = (getAutogeneratedOnly = false, copiesFileLocation = mainCopiesFileLocation ) => {
    const nodes = [];

    const translationNodes = this.getTranslationNodesFromFile(copiesFileLocation);

    translationNodes.forEach(translationNode => {
      let isSkipped = false;
      pathsToSkip.forEach(path => {
        if (translationNode.source && translationNode.source.startsWith(path)) {
          isSkipped = true;
          return;
        }
      });

      if (isSkipped) {
        return;
      }

      if (getAutogeneratedOnly) {
        const id = translationNode.id;
        const isKeyIdGenerated = this.isKeyNumeric(id);
        if (isKeyIdGenerated) {
          nodes.push(translationNode);
        }
      } else {
        nodes.push(translationNode);
      }
    });

    return nodes;
  }

  private generateKeyByPath(path) {
    const pathWithoutFilelines = path.split(':')[0];
    const pathWithoutExtension = pathWithoutFilelines.replace('.component.html', '');
    const normalizedPath = pathWithoutExtension.replace(/-/g, '/');
    const splittedBySlash = normalizedPath.split('/');
    const keyName = splittedBySlash.slice(4, splittedBySlash.length + 1).join('_');
    const normalizedKeyname = this.generateNormalizedKey(keyName);

    this.cumulativeIndex++;
    return `${normalizedKeyname}_${this.cumulativeIndex}`;
  }

  private getNewKeyName(node) {
    const isAutogenerated = this.isKeyNumeric(node.id);
    if (isAutogenerated) {
      return this.generateKeyByPath(node.source);
    } else {
      return this.generateNormalizedKey(node.id);
    }
  }

  private setNewKeyNameInHTML(node, newKeyName) {
    const splittedPath = node.source.split(':');
    const filePath = splittedPath[0];
    const keyPosition = splittedPath[1];
    // Note: only checking first line because breaklines where removed
    const translationLinePositionInFile = parseInt(keyPosition.split(',')[0], 0);

    const rawHTML = fs.readFileSync(filePath, 'UTF-8');
    const allLines = rawHTML.split(/\r?\n/);
    let targetLine = allLines[translationLinePositionInFile];
    targetLine  = targetLine.replace(/="@(.*?)(?=")"/g, '');

    const isPlaceholder = targetLine.includes('i18n-placeholder');
    if (isPlaceholder) {
      targetLine = targetLine.replace('i18n-placeholder', `i18n-placeholder="@@${newKeyName}"`);
    } else {
      targetLine = targetLine.replace('i18n', `i18n="@@${newKeyName}"`);
    }

    allLines[translationLinePositionInFile] = targetLine;
    const formattedRawHTML = allLines.join('\n');
    fs.writeFileSync(filePath, formattedRawHTML);
  }

  private setKeysInMainCopies(keysToBeUpdated) {
    let rawFile = fs.readFileSync(mainCopiesFileLocation, 'utf8');

    keysToBeUpdated.forEach(key => {
      const regexpFindOldKey = new RegExp(`"${key.old}"`, 'g');
      rawFile = rawFile.replace(regexpFindOldKey, `"${key.new}"`);
    });

    fs.writeFileSync(mainCopiesFileLocation, rawFile);
  }

  private setKeysInOtherCopies(keysToBeUpdated, filePath) {
    let rawFile = fs.readFileSync(filePath, 'utf8');
    const newTranslations = [];

    keysToBeUpdated.forEach(key => {
      const isOldKeyInFile = rawFile.includes(key.old);
      if (isOldKeyInFile) {
        rawFile = rawFile.replace(key.old, key.new);
        return;
      }

      const wasNumeric = this.isKeyNumeric(key.old);
      if (wasNumeric) {
        const translation = this.translations.find(t => t.numericKey && t.numericKey === key.old);

        if (!translation) {
          return;
        }

        const replaceGreaterThanRegExp = new RegExp(this.escapeGreaterThan, 'g');
        const replaceLesserThanRegExp = new RegExp(this.escapeLesserThan, 'g');
        const cleanTranslation = translation.es
          .replace(replaceLesserThanRegExp, '<')
          .replace(replaceGreaterThanRegExp, '>');

        const newTranslation = `<translation id="${key.new}">${cleanTranslation}</translation>`;
        newTranslations.push(newTranslation);
      }
    });

    // Touring is crying in a corner right now
    const hasPendingTranslations = newTranslations.length !== 0;
    if (hasPendingTranslations) {
      let allLines = rawFile.split('\n');
      const lastTwoLines = allLines.splice(allLines.length - 2, 2);
      allLines = allLines.concat(newTranslations);
      allLines = allLines.concat(lastTwoLines);
      rawFile = allLines.join('\n');
    }

    fs.writeFileSync(`${filePath}`, rawFile);
  }

  private setKeysInCopies(keysToBeUpdated) {
    translationsFilesLocations.forEach(translationFilePath => {
      if (translationFilePath !== mainCopiesFileLocation) {
        this.setKeysInOtherCopies(keysToBeUpdated, translationFilePath);
      }
    });
  }

  private syncAngularMessages() {
    execSync('yarn i18n');
  }

  private commitTranslationsDiff() {
    execSync('git add .');
    execSync(`git commit -m "Translations synced (${this.recursiveIteration})"`);
  }

  private addMissingKeys(needsAngularSync = true) {
    const updatedKeys = [];

    if (needsAngularSync) {
      this.syncAngularMessages();
    }

    // Get XML nodes that are generated automatically and don't have manual key
    const nodeMessagesWithoutKeyname = this.getNodeMessages(true);
    nodeMessagesWithoutKeyname.forEach((node) => {
      // Get new key name
      const newKeyName = this.getNewKeyName(node);

      // Set key in HTML file
      this.setNewKeyNameInHTML(node, newKeyName);

      // Store old keys to be updated
      updatedKeys.push({ old: node.id, new: newKeyName });
    });

    // Replace old keys for new ones in copies
    this.setKeysInCopies(updatedKeys);

    // Save iteration in a git commit
    this.commitTranslationsDiff();

    // Regenerate Angular messages
    this.syncAngularMessages();

    const nodeMessagesWithoutKeyCheck = this.getNodeMessages(true);
    if (nodeMessagesWithoutKeyCheck.length !== 0) {
      console.log('Still missing keys, running again...');
      this.recursiveIteration++;
      this.addMissingKeys(false);
    }

    return updatedKeys;
  }

  private snakeCase(string) {
    return string.charAt(0).toLowerCase() + string.slice(1)
      .replace(/\W+/g, ' ')
      .replace(/([a-z])([A-Z])([a-z])/g, '$1 $2$3')
      .split(/\B(?=[A-Z]{2,})/)
      .join(' ')
      .split(' ')
      .join('_')
      .toLowerCase();
  }

  private generateNormalizedKey(key) {
    let newKey = this.snakeCase(key);
    const needsPrefix = !newKey.startsWith(keyPrefix);
    if (needsPrefix) {
      newKey = `${keyPrefix}${newKey}`;
    }

    const onlyUniqueFilter = (value, index, self) => {
      return self.indexOf(value) === index;
    };

    return newKey.split('_').filter(onlyUniqueFilter).join('_');
  }

  private normalizeKeys() {
    const keysToNormalize: {old: string, new: string}[] = [];

    const allNodes = this.getNodeMessages();

    allNodes.forEach(node => {
      const oldKey = node.id;
      const normalizedKey = this.generateNormalizedKey(oldKey);

      const needsModification = normalizedKey !== oldKey;
      if (needsModification) {
        keysToNormalize.push({ old: oldKey, new: normalizedKey });
        this.setNewKeyNameInHTML(node, normalizedKey);
      }
    });

    this.setNewKeyInMainCopies(keysToNormalize);
  }

  private setNewKeyInMainCopies = (keysToNormalize: {old: string, new: string}[]) => {

  }
}

new I18nNormalizer().main();
