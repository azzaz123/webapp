const fs = require('fs');
const xmlParser = require('xml2json');
const { execSync } = require('child_process');

const englishCopiesFileLocation = 'src/locale/messages.xmb';
const spanishCopiesFileLocation = 'src/locale/es.xtb';
const keyNamePrefix = 'web_';
const translationsFilesLocations = [
  englishCopiesFileLocation,
  spanishCopiesFileLocation
];
const pathsToSkip = [
  'node_modules'
]

const getNodeMessages = (getAutogeneratedOnly = false) => {
  const nodes = [];
  const rawEnglishCopiesFile = fs.readFileSync(englishCopiesFileLocation, 'utf8');
  const rawEngCopiesWithTextTags = 
    rawEnglishCopiesFile
      .replace(/<\/source>/g, '</source><text>')
      .replace(/<\/msg>/g, '</text></msg>')
      .replace(/<ph.*\/>/g, '__INTERPOLATION__ ')
  const rawMessagesBundle = xmlParser.toJson(rawEngCopiesWithTextTags);
  const englishCopiesFileObject = JSON.parse(rawMessagesBundle);
  const translationNodes = englishCopiesFileObject.messagebundle.msg;

  translationNodes.forEach(translationNode => {
    let isSkipped = false;
    pathsToSkip.forEach(path => {
      if (translationNode.source.startsWith(path)) {
        isSkipped = true;
        return;
      }
    });

    if (isSkipped) {
      return;
    }

    if (getAutogeneratedOnly) {
      const id = translationNode.id;
      const isKeyIdGenerated = !isNaN(id) && !isNaN(parseFloat(id));
      if (isKeyIdGenerated) {
        nodes.push(translationNode);
      }
    } else {
      nodes.push(translationNode);
    }
  })

  return nodes;
}

let cummulativeIndex = 0;

const getNewKeyName = node => {
  const pathWithoutFilelines = node.source.split(':')[0];
  const pathWithoutExtension = pathWithoutFilelines.replace('.component.html', '');
  const normalizedPath = pathWithoutExtension.replace(/-/g, '/');
  const splittedBySlash = normalizedPath.split('/');
  const keyName = splittedBySlash.slice(4, splittedBySlash.length + 1).join('_');
  const normalizedKeyname = getNormalizedKey(keyName)

  cummulativeIndex++;
  return `${normalizedKeyname}_${cummulativeIndex}`;
}

const setNewKeyNameInHTML = (node, newKeyName) => {
  const splittedPath = node.source.split(':');
  const filePath = splittedPath[0];
  const keyPosition = splittedPath[1];
  // Note: only checking first line because breaklines where removed
  const translationLinePositionInFile = parseInt(keyPosition.split(',')[0]);

  const rawHTML = fs.readFileSync(filePath, 'UTF-8');
  const allLines = rawHTML.split(/\r?\n/);
  let targetLine = allLines[translationLinePositionInFile];
  targetLine  = targetLine.replace(/="@(.*?)(?=")"/g, '');

  const isPlaceholder = targetLine.includes('i18n-placeholder');
  if (isPlaceholder) {
    targetLine = targetLine.replace('i18n-placeholder', `i18n-placeholder="@@${newKeyName}"`);
  } else {
    targetLine = targetLine.replace('i18n', `i18n="@@${newKeyName}"`);
  }

  allLines[translationLinePositionInFile] = targetLine;
  const formattedRawHTML = allLines.join('\n');
  fs.writeFileSync(filePath, formattedRawHTML);
}

const setNewKeyNameInCopies = keysToBeUpdated => {
  translationsFilesLocations.forEach(fileLocation => {
    let rawFile = fs.readFileSync(fileLocation, 'utf8');

    keysToBeUpdated.forEach(key => {
      const regexpFindOldKey = new RegExp(`"${key.old}"`, 'g');
      rawFile = rawFile.replace(regexpFindOldKey, `"${key.new}"`);
    });

    fs.writeFileSync(fileLocation, rawFile)
  });
}

const syncAngularMessages = () => {
  execSync('yarn i18n');
}

const commitTranslationsDiff = () => {
  execSync('git add .');
  execSync(`git commit -m "Translations synced (${recursiveIteration})"`)
}

let recursiveIteration = 0;
const addMissingKeys = (needsAngularSync = true) => {
  if (needsAngularSync) {
    syncAngularMessages();
  }

  // Get XML nodes that are generated automatically and don't have manual key
  const nodeMessagesWithoutKeyname = getNodeMessages(true);
  const keysToBeUpdated = [];

  nodeMessagesWithoutKeyname.forEach((node, i) => {
    // Get new key name
    const newKeyName = getNewKeyName(node, i);

    // Set key in HTML file
    setNewKeyNameInHTML(node, newKeyName);

    // Store old keys to be updated
    keysToBeUpdated.push({ old: node.id, new: newKeyName });
  });

  // Replace old key for new one in copies
  setNewKeyNameInCopies(keysToBeUpdated);

  commitTranslationsDiff();

  const recursive = true;
  if (recursive) {
    syncAngularMessages();
    const nodeMessagesWithoutKeyCheck = getNodeMessages(true);
    if (nodeMessagesWithoutKeyCheck.length !== 0) {
      console.log('Still missing keys, running again...');
      recursiveIteration++;
      addMissingKeys(false)
    }
  }
}

const snakeCase = string => {
  return string.charAt(0).toLowerCase() + string.slice(1)
  .replace(/\W+/g, " ")
  .replace(/([a-z])([A-Z])([a-z])/g, "$1 $2$3")
  .split(/\B(?=[A-Z]{2,})/)
  .join(' ')
  .split(' ')
  .join('_')
  .toLowerCase();
}

const getNormalizedKey = keyname => {
  let newKeyname = snakeCase(keyname);
  const needsPrefix = !newKeyname.startsWith(keyNamePrefix);
  if (needsPrefix) {
    newKeyname = `${keyNamePrefix}${newKeyname}`;
  }

  const onlyUniqueFilter = (value, index, self) => {
    return self.indexOf(value) === index;
  }
  
  const keyNameWithUniqueValues = newKeyname.split('_').filter(onlyUniqueFilter).join('_');
  return keyNameWithUniqueValues;
}

const normalizeKeys = () => {
  const keysToNormalize = [];

  const allNodes = getNodeMessages();

  allNodes.forEach(node => {
    const oldKey = node.id;
    const normalizedKey = getNormalizedKey(oldKey);

    const needsModification = normalizedKey !== oldKey;
    if (needsModification) {
      keysToNormalize.push({ old: oldKey, new: normalizedKey })
      setNewKeyNameInHTML(node, normalizedKey);
    }
  });

  setNewKeyNameInCopies(keysToNormalize);
}

const main = () => {
  // Ensure all i18n copies have manual keys and update copies
  // addMissingKeys();

  // Format all keys with snake_case, add prefix and simplify key name
  // normalizeKeys();
}

main();
