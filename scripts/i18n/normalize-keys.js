const fs = require('fs');
const xmlParser = require('xml2json');
const { execSync } = require('child_process');

const englishCopiesFileLocation = 'src/locale/messages.xmb';
const spanishCopiesFileLocation = 'src/locale/es.xtb';
const mainCopiesFileLocation = englishCopiesFileLocation;
const keyNamePrefix = 'web_';
const translationsFilesLocations = [
  englishCopiesFileLocation,
  spanishCopiesFileLocation
];
const pathsToSkip = [
  'node_modules'
];
// El tete pilota
const escapeGreaterThan = '$GREATER_THAN';
const escapeLesserThan = '$LESSER_THAN';
const translations = []

const loadTranslationsDatabase = () => {
  const originalNodeMessages = getNodeMessages(false, englishCopiesFileLocation);
  const spanishNodeMessages = getNodeMessages(false, spanishCopiesFileLocation);

  originalNodeMessages.forEach(originalNodeMessages => {
    spanishNodeMessages.forEach(spanishNodeMessages => {
      const isSameId = originalNodeMessages.id === spanishNodeMessages.id;

      if (isSameId) {
        const numericKey = isKeyNumeric(originalNodeMessages.id) ? originalNodeMessages.id : null;
        const translationRelation = {
          numericKey,
          mainKey: originalNodeMessages.id,
          es: spanishNodeMessages.text,
          en: originalNodeMessages.text
        }
        translations.push(translationRelation)
      }
    })
  })
}

const cleanupRawXMB = rawStringFile => {
  const translationTagSeparator = `msg`;
  const regexpMatchTranslationSeparatorsAperture = new RegExp(`</source>`, 'g');
  const regexpMatchTranslationSeparatorsClosure = new RegExp(`</${translationTagSeparator}>`, 'g');
  const apertureReplacement = '</source><text>';
  const closureReplacement = `</text></${translationTagSeparator}>`;
  const regexpCleanupInterpolations = new RegExp('/<ph.*\/>/', 'g');
  const interpolationsReplacement = '__INTERPOLATION__';

  const cleanedString = rawStringFile
    .replace(regexpMatchTranslationSeparatorsAperture, apertureReplacement)
    .replace(regexpMatchTranslationSeparatorsClosure, closureReplacement)
    .replace(regexpCleanupInterpolations, interpolationsReplacement);
  return cleanedString;
}

const cleanupRawXTB = rawStringFile => {
  const allLines = rawStringFile.split('\n');
  allLines.forEach((line, i) => {
    line = line.replace(/<ph/g, `${escapeGreaterThan}ph`);
    line = line.replace(/<ex>/g, `${escapeGreaterThan}ex${escapeLesserThan}`)
    line = line.replace(/<\/ex>/g, `${escapeGreaterThan}/ex${escapeLesserThan}`)
    line = line.replace(/<\/ph>/g, `${escapeGreaterThan}/ph${escapeLesserThan}`)
    allLines[i] = line;
  });

  const cleanedString = allLines.join('\n');
  return cleanedString;
}

const getTranslationNodesFromFile = (copiesFileLocation) => {
  const rawCopiesFile = fs.readFileSync(copiesFileLocation, 'utf8');

  const isXMB = copiesFileLocation.endsWith('.xmb');
  const isXTB = copiesFileLocation.endsWith('.xtb');

  if (isXMB) {
    const cleanedFileString = cleanupRawXMB(rawCopiesFile);
    const rawCopiesJSON = xmlParser.toJson(cleanedFileString);
    const copiesObject = JSON.parse(rawCopiesJSON);
    return copiesObject.messagebundle.msg;
  }

  if (isXTB) {
    const cleanedFileString = cleanupRawXTB(rawCopiesFile);
    const rawCopiesJSON = xmlParser.toJson(cleanedFileString, { alternateTextNode: 'text' } );
    const copiesObject = JSON.parse(rawCopiesJSON);
    return copiesObject.translationbundle.translation;
  }
  
  return [];
}

const isKeyNumeric = id => !isNaN(id) && !isNaN(parseFloat(id));

const getNodeMessages = (getAutogeneratedOnly = false, copiesFileLocation = mainCopiesFileLocation ) => {
  const nodes = [];
  
  const translationNodes = getTranslationNodesFromFile(copiesFileLocation);

  translationNodes.forEach(translationNode => {
    let isSkipped = false;
    pathsToSkip.forEach(path => {
      if (translationNode.source && translationNode.source.startsWith(path)) {
        isSkipped = true;
        return;
      }
    });

    if (isSkipped) {
      return;
    }

    if (getAutogeneratedOnly) {
      const id = translationNode.id;
      const isKeyIdGenerated = isKeyNumeric(id);
      if (isKeyIdGenerated) {
        nodes.push(translationNode);
      }
    } else {
      nodes.push(translationNode);
    }
  })

  return nodes;
}

let cummulativeIndex = 0;

const generateKeyByPath = path => {
  const pathWithoutFilelines = path.split(':')[0];
  const pathWithoutExtension = pathWithoutFilelines.replace('.component.html', '');
  const normalizedPath = pathWithoutExtension.replace(/-/g, '/');
  const splittedBySlash = normalizedPath.split('/');
  const keyName = splittedBySlash.slice(4, splittedBySlash.length + 1).join('_');
  const normalizedKeyname = generateNormalizedKey(keyName)

  cummulativeIndex++;
  return `${normalizedKeyname}_${cummulativeIndex}`;
}

const getNewKeyName = node => {
  const isAutogenerated = isKeyNumeric(node.id);
  if (isAutogenerated) {
    let newMainKey;
    try {
      const translationById = translations.find(translation => translation.numericKey === node.id);
      const translationNeedsMainKey = isKeyNumeric(translationById.mainKey);
      newMainKey = generateKeyByPath(node.source);
  
      if (translationNeedsMainKey) {
        translationById.mainKey = newMainKey;
      }

    } catch (error) {
      console.log('Problematic node found', node)
      console.log(error)
    }
    return newMainKey;
  } else {
    return generateNormalizedKey(node.id);
  }
}

const setNewKeyNameInHTML = (node, newKeyName) => {
  const splittedPath = node.source.split(':');
  const filePath = splittedPath[0];
  const keyPosition = splittedPath[1];
  // Note: only checking first line because breaklines where removed
  const translationLinePositionInFile = parseInt(keyPosition.split(',')[0]);

  const rawHTML = fs.readFileSync(filePath, 'UTF-8');
  const allLines = rawHTML.split(/\r?\n/);
  let targetLine = allLines[translationLinePositionInFile];
  targetLine  = targetLine.replace(/="@(.*?)(?=")"/g, '');

  const isPlaceholder = targetLine.includes('i18n-placeholder');
  if (isPlaceholder) {
    targetLine = targetLine.replace('i18n-placeholder', `i18n-placeholder="@@${newKeyName}"`);
  } else {
    targetLine = targetLine.replace('i18n', `i18n="@@${newKeyName}"`);
  }

  allLines[translationLinePositionInFile] = targetLine;
  const formattedRawHTML = allLines.join('\n');
  fs.writeFileSync(filePath, formattedRawHTML);
}

const setNewKeyNameInMainCopies = keysToBeUpdated => {
  let rawFile = fs.readFileSync(mainCopiesFileLocation, 'utf8');

  keysToBeUpdated.forEach(key => {
    const regexpFindOldKey = new RegExp(`"${key.old}"`, 'g');
    rawFile = rawFile.replace(regexpFindOldKey, `"${key.new}"`);
  });

  fs.writeFileSync(mainCopiesFileLocation, rawFile)
}

const setFinalKeysInOtherCopies = keysToBeUpdated => {
  console.log('tobeuopdated', keysToBeUpdated)

  const otherCopiesFiles = translationsFilesLocations.filter(file => file !== mainCopiesFileLocation);
  otherCopiesFiles.forEach(file => {
    let rawFile = fs.readFileSync(file, 'utf8');
    const allLines = rawFile.split('\n');

    keysToBeUpdated.forEach(key => {
      const isKeyNotInFile = !rawFile.includes(key.new); 
      if (isKeyNotInFile) {
        const translation = translations.find(t => t.numericKey && t.numericKey === key.old);
        const cleanTranslation = translation.es
        .replace(escapeGreaterThan, '>')
        .replace(escapeLesserThan, '<')

        allLines[allLines.length - 1] = `<translation id="${key.new}>${cleanTranslation}</translation>`;
      } else {
        rawFile = rawFile.replace(key.old, key.new)
      }
    })

    fs.writeFileSync(`${file}-2.xtb`, allLines.join('\n'))
  });
}

const syncAngularMessages = () => {
  execSync('yarn i18n');
}

const commitTranslationsDiff = () => {
  execSync('git add .');
  execSync(`git commit -m "Translations synced (${recursiveIteration})"`)
}

let recursiveIteration = 0;
const keysToBeUpdated = [];
const addMissingKeys = (needsAngularSync = true) => {
  if (needsAngularSync) {
    syncAngularMessages();
  }

  // Get XML nodes that are generated automatically and don't have manual key
  const nodeMessagesWithoutKeyname = getNodeMessages(true);

  nodeMessagesWithoutKeyname.forEach((node, i) => {
    // Get new key name
    const newKeyName = getNewKeyName(node, i);

    // Set key in HTML file
    setNewKeyNameInHTML(node, newKeyName);

    // Store old keys to be updated
    keysToBeUpdated.push({ old: node.id, new: newKeyName });
  });

  // Replace old key for new one in copies
  setNewKeyNameInMainCopies(keysToBeUpdated);
  setFinalKeysInOtherCopies(keysToBeUpdated);

  commitTranslationsDiff();

  const recursive = true;
  if (recursive) {
    syncAngularMessages();
    const nodeMessagesWithoutKeyCheck = getNodeMessages(true);
    if (nodeMessagesWithoutKeyCheck.length !== 0) {
      console.log('Still missing keys, running again...');
      recursiveIteration++;
      addMissingKeys(false)
    }
  }
}

const snakeCase = string => {
  return string.charAt(0).toLowerCase() + string.slice(1)
  .replace(/\W+/g, " ")
  .replace(/([a-z])([A-Z])([a-z])/g, "$1 $2$3")
  .split(/\B(?=[A-Z]{2,})/)
  .join(' ')
  .split(' ')
  .join('_')
  .toLowerCase();
}

const generateNormalizedKey = keyname => {
  let newKeyname = snakeCase(keyname);
  const needsPrefix = !newKeyname.startsWith(keyNamePrefix);
  if (needsPrefix) {
    newKeyname = `${keyNamePrefix}${newKeyname}`;
  }

  const onlyUniqueFilter = (value, index, self) => {
    return self.indexOf(value) === index;
  }
  
  const keyNameWithUniqueValues = newKeyname.split('_').filter(onlyUniqueFilter).join('_');
  return keyNameWithUniqueValues;
}

const normalizeKeys = () => {
  const keysToNormalize = [];

  const allNodes = getNodeMessages();

  allNodes.forEach(node => {
    const oldKey = node.id;
    const normalizedKey = generateNormalizedKey(oldKey);

    const needsModification = normalizedKey !== oldKey;
    if (needsModification) {
      keysToNormalize.push({ old: oldKey, new: normalizedKey })
      setNewKeyNameInHTML(node, normalizedKey);
    }
  });

  setNewKeyNameInMainCopies(keysToNormalize);
}

const main = () => {
  // Load in memory original translations
  loadTranslationsDatabase();

  // Ensure all i18n copies have manual keys and update copies
  addMissingKeys();

  // Format all keys with snake_case, add prefix and simplify key name
  // normalizeKeys();
}

main();
